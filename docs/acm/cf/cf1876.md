
!!! abstract
    - [x] 1894. Codeforces Round 908 (Div. 2)
        - D. Neutral Tonality
        - E. Freedom of Choice
    - [ ] 1895. Educational Codeforces Round 157 (Rated for Div. 2)
        - D. XOR Construction：异或
        - E. Infinite Card Game：博弈论；拓扑序


## 1894. [Codeforces Round 908 (Div. 2)](https://codeforces.com/contest/1894)

### [D. Neutral Tonality](https://codeforces.com/contest/1894/problem/D)

**Description**

给定两个序列 $\{a_n\}$ 和 $\{b_m\}$，你可以将 $\{b_m\}$ 以任意顺序插入到 $\{a_n\}$ 中的任意位置，求该如何插入使得获得的新序列 $\{c_{n + m}\}$ 中最长上升子序列长度最小。

**Solution**

设 $\{a_n\}$ 的最长上升子序列长度为 $S$，仔细思考之后发现 $\{c_{n + m}\}$ 的最长上升子序列长度一定是大于等于 $S$，小于等于 $S + 1$ 的。为什么小于等于 $S + 1$ 呢？因为我们可以把 $\{b_m\}$ 序列降序排列后插入 $\{a_n\}$ 中，在 $\{c_{n + m}\}$ 的最长上升子序列中，$\{b_m\}$ 中的元素最多只会出现一次，故长度一定是小于等于 $S + 1$ 的。

那么什么时候可以把长度变为 $S$ 呢，事实上是一定能变为 $S$ 的。我们把 $\{b_m\}$ 序列降序排列，然后考虑若长度可以变为 $S + 1$ 时，那么一定在原有最长上升子序列的某两个 $a_i$，$a_{i + 1}$ 中间可以再选一个 $b_j$ 放进去，所以我们可以让比 $a_i$ 大的数都在 $a_i$ 之前放进去，比 $a_i$ 小的数都在 $a_i$ 之后放进去。对于 $\{a_n\}$ 中的某个上升序列来说，我们虽然不能保证 $a_i$ 前面的元素都比它大，但能保证后面的元素都比它小。故不能在 $a_i$，$a_{i + 1}$ 中间再插入 $\{b_m\}$ 中元素。

具体实现可以用双指针，每次将 $\{a_n\}$ 和 $\{b_m\}$ 中较大的元素插入 $\{c_{n + m}\}$ 中即可。

[Code](https://codeforces.com/contest/1894/submission/232046392)

### [E. Freedom of Choice](https://codeforces.com/contest/1894/problem/E)

**Description**

给定 $m$ 个可重集，第 $i$ 个可重集中有 $n_i$ 个元素，对于第 $i$ 个可重集你可以选择其中若干元素，选择的元素个数介于 $l_i$ 到 $r_i$ 之间。最后把 $m$ 次选择的元素合在一起得到一个新的可重集，设里面元素个数为 $len$，问如何选择使得得到的可重集中 $len$ 这个数出现次数最少，求出其出现次数。

**Solution**

若 $\sum r_i - \sum r_i > \sum n_i$，那么我们一定可以凑出某一个数 $x$，使得它介于 $l_i$ 到 $r_i$ 之间且不等于 $m$ 个可重集中任一元素，故此时答案一定为 $0$。接下来主要考虑 $\sum r_i - \sum r_i \le \sum n_i$ 的情况，我们可以枚举最后要选的个数 $x$，然后对于每个可重集，如果里面没有 $x$ 元素，那么我们就取 $r_i$ 个，如果有 $x$ 元素，那么我们就分情况讨论一下，先把其中的 $x$ 除掉，然后把剩下的都选上，要是把除了 $x$ 之外的元素都除去了还是选不到 $l_i$ 个，就选 $x$ 元素补到 $l_i$ 个；要是把除了 $x$ 之外的元素都除去了之后超过 $l_i$ 个了，就尽量在不超过 $r_i$ 的情况下多选。

这样做所得到的一定是最优的。因为我们会发现选择 $x$ 元素只有两种原因：一是某个可重集少于 $l_i$ 不得不选，二是总体一共选的小于 $x$ 个了所以要选 $x$ 补充。对于前者显然是把其他能选的都选上，若没到 $l_i$ 选 $x$ 来补充；对于后者，我们可以让“有余力”的集合尽量多选，也就是选 $r_i$ 个，显然上述做法都是满足的。

如果前面选的多了导致最后几个可重集没选到 $l_i$ 就达到 $x$ 会怎么样？事实上不用担心这种情况，因为可以让前面那些选择超过 $l_i$ 的可重集选择个数减少，而且那些选择超过 $l_i$ 的可重集对于答案的贡献一定都是 $0$，所以不会有影响，并且由于 $x \ge \sum l_i$，所以让前面减少的过程中一定会有一个零界点使得所选个数之和为 $x$。

[Code](https://codeforces.com/contest/1894/submission/232054625)

## 1895. [Educational Codeforces Round 157 (Rated for Div. 2)](https://codeforces.com/contest/1895)

### [D. XOR Construction](https://codeforces.com/contest/1895/problem/D)

**Description**

给定一个长度为 $n - 1$ 的序列 $\{a_n\}$，要求一个长度为 $n$ 的序列 $\{b_n\}$，使得 $0 \sim n - 1$ 每个数都在 $\{b_n\}$ 中恰好出现了一次，并且满足 $b_i \oplus b_{i + 1} = a_i$，试求出这样的 $\{b_n\}$ 序列。

**Solution**

稍作化简我们不难发现

\begin{align*}
&b_1 = b_1 \\
&b_2 = b_1 \oplus a_1 \\
&b_3 = b_1 \oplus a_1 \oplus a_2 \\
& \dots \\
&b_n = b_1 \oplus a_1 \oplus \cdots \oplus a_{n - 1}
\end{align*}

对于异或的题目要多往拆位方面上去想，我们可以把 $b_1$ 拆成一位位分别去求。我们设前缀和数组 $\{c_n\}$，其中 $c_i$ 表示前 $i$ 个 $a_i$ 的异或和。若想判断一下 $b_i$ 第 $i$ 位上是不是 $1$，我们只用比较一下全部 $\{c_n\}$ 中第 $i$ 位上 $1$ 的个数和前 $n - 1$ 个数的第 $i$ 位上 $1$ 的个数总和是否相等，若相等则说明 $b_1$ 第 $i$ 位是 $0$，反之说明是 $1$。

[Code](https://codeforces.com/contest/1895/submission/232185699)

### [E. Infinite Card Game](https://codeforces.com/contest/1895/problem/E)

**Description**

有 A 和 B 两名玩家，A 玩家有 $n$ 张牌，B 玩家有 $m$ 张牌。每张牌都有一个攻击值和防御值，首先由 A 玩家使用一张牌，接着由 B 玩家出牌，且出的牌必须攻击值大于 A 的牌的防御值，被击败的牌将退回原玩家手中，两人依次出牌，最后谁出不了怕牌就输掉比赛。

比赛过程中两人均按照最优解出牌，请问 A 的 $n$ 张牌中，有几张牌 A 第一次出会使 A 赢得比赛，有几张牌 A 第一次出会使比赛平局，有几张牌 A 第一次出会使 A 输掉比赛。


**Solution**

我们发现一旦可以把牌击败之后，场上牌的攻击值就不重要了，只有防御值重要，且越大越好。所以我们可以直接用贪心思路，每次在能击败的基础上选防御值最大的牌。所以一旦前面的牌固定下来之后，后面的出牌一定也是固定的。我们可以将这张牌和这张牌的应对牌之间连一条边，最后跑一下拓扑排序即可求出每个牌最后对应的状态。特别说明一下，如果最后是平局说明出现了环，判断一下入度个数即可。


[Code](https://codeforces.com/contest/1895/submission/232383221)