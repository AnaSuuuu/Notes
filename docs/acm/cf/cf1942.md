# [CodeTON Round 8 (Div. 1 + Div. 2, Rated, Prizes!)](https://codeforces.com/contest/1942)

## [C2. Bessie's Birthday Cake (Hard Version)](https://codeforces.com/contest/1942/problem/C2)

**Solution:**

  Observing carefully, we can find out the most optimized strategy is to choose the point alternatively.

  And we set the point we used black, the others white.

  We count number of the single white point between black points is $k_1$, the number of black points is $k_2$, so the answer is $k_1 + k_2 - 2$.

  For two black points, if the white points between them is $d$, the maximum of the contribution is $\left \lceil \dfrac{d}{2} \right \rceil$.

  So we should choose the white points alternatively to maximize the answer with steps no more than y.

  But we can find that for the $d$ which is odd, it can make more contributions than $d$ which is even with the same steps.

  And for two ds which are both odd or both even, the smaller d is better.

  So we can find out all the ds, and sort them by the rules above. Then we can implement the strategy greedily.

## [D. Learning to Paint](https://codeforces.com/problemset/problem/1942/D)

**Solution:**

  Good problem.

  We can use DP to solve the problem. 

  And cause we want to solve the largest k values, so $f_i$ denotes the largest k status where the latest choosed pattern isn't bigger than i.

  When need to transform the $f_i$, we should choose the $j \in [1, i - 2]$. And there's a gap between $i$ and $j$.
  So $f_i = \max \{f[j] + a[j + 2][i]\}$.

  But we can know that there're $k$ statutes in $f_i$. So we can use the `priority_queue` to note it.

!!! note

    $f_i$ is a two-dimension array.
    
    But to simplified, I write down the transformation above denotes that for all $j \in [1, k]$, $f[i][j] = \max \{f[j] + a[j + 2][i]\}$
 
  We can put the first $i - 2$ of f array's top to the priority queue Q.

  Then we should repeat the performance below for k times:

  1. pop the top of Q, and find where the top element belong to.
  2. put the adjacent element of the top in that f array.

  Finally, the answer is the first element in $f_n$.

  We can find all the status can be covered in our transformations, so the dp is correct.

## [E. Farm Game](https://codeforces.com/problemset/problem/1942/E)

**Solution:**

  Good problem.

  **Game theory + combinatorics**

  Let's suppose $a_1 < b_1 < a_2 < b_2 < ... < a_n < b_n$.

  ($b_1 < a_1 < b_2 < a_2 < ... < b_n < a_n$ can be the same.)

  Observing carefully, we can find the first hand will lose if all $b_i - a_i - 1 \equiv 0 \pmod{2}$ 

  So the winning planning is all planning substract losing planning.

  But how to get losing planning? We set $\sum (b_j - a_j - 1) = i$.

  Then we can find how many choices to fix $a_j$, it's $\binom{l - n - i}{n}$.

  And for the length of each $b_i - a_i$, it's like put the partition in balls, where can be empty during two partitions.
  The answer is $\binom{n - 1 + i / 2}{n - 1}$.

!!! tip

    $i / 2$ can satisfied that every number between partitions is even.

  And the total losing planning is $\sum \binom{n - 1 + i}{n - 1} \times \binom{l - n - i}{n}$.

