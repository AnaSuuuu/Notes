---
title: 算法笔记 | 字符串（一）
date: 2023-07-10 11:11:13
tags:
---

!!! abstract
    - Manacher
    - KMP

<!--more-->

## 1. Manacher 算法

### 1.1 算法介绍

该算法可以线性求出字符串的以各个位置为轴的回文子串最大长度

### 1.2 过程

本算法求的是以各位置为对称中心的最大对称半径是多少，由于会出现长度为奇数的对称区间（对称中心在两个位置中间），偶数长度的对称区间（对称中心在某一个位置处）。所以我们对原字串进行变换，比如 `abcba` 变为 `##a#b#c#b#a#` ，这样的话对称中心就是这个位置本身了。

我们引入一个数组 $len$ ，$len$ 数组表示这个点能够扩展出的回文长度。

我们从前向后遍历一遍，循环变量为 $i$，引入辅助变量 $maxr$ 和 $mid$ ，$maxr$ 表示触及到的最右边的字符位置，$mid$ 表示包含 $maxr$ 回文串的中心轴所在位置。对于每次遍历到的新的位置 $i$，不难发现如果 $i < maxr$，那么 $len[i] = min\{len[mid] \}$

当 $i$ 在 $maxr$ 左边且在 $mid$ 右边时：

设 $i$ 关于 $mid$ 的对称点为 $j$，显然 $len[i]$ 一定不会小于 $len[j]$（对称）。

其中 $j$ 为 $(mid<<1)−i$。

那么我们就设置 $len[i] = min\{len[mid], maxr - i \}$ 然后继续尝试扩展，这样就可以较快地求出 $len[i]$，然后更新 $maxr$ 和 $mid$

当 $i$ 在 $maxr$ 右边时，我们无法得知关于 $len[i]$ 的信息，只好从 $1$ 开始遍历，然后更新 $maxr$ 和 $mid$。

本算法时间复杂度和空间复杂度均为线性的。

### 1.3 实现

```c++
void update() {
  s2[0] = s2[1] = '#';
  for(int i = 1; i <= n; i++) {
    s2[i << 1] = s1[i];
    s2[i << 1 | 1] = '#';
  }
  n = 2 * n + 1;
}

void manacher() {
  int maxr = 0, mid = 0;
  for(int i = 1; i <= n; i++) {
    if(i < maxr) len[i] = min(len[(mid << 1) - i], len[mid] + mid - i);
    else len[i] = 1;
    while(i + len[i] <= n &&  i - len[i] > 0 && s2[i + len[i]] == s2[i - len[i]]) len[i]++;
    if(len[i] + i > maxr) {
      maxr = len[i] + i;
      mid = i; 
    } 
  }
}
```



## 2. KMP 算法

### 2.1 前缀函数

给定一个长度为 $n$ 的字符串 $s$，其前缀函数被定义为一个长度为 $n$ 的数组 $\pi$。 其中 $\pi[i]$ 的定义是：最长的相等的真后缀真前缀长度（自身除外），举个例子，字串 $s[0\dots i]$ 有一对相等的真前缀 $s[0\dots k - 1]$ 和真后缀 $s[i - (k - 1) \dots i]$ 它们相等且是这个字串中所能找到最长的前缀后缀，那么 $\pi[i] = k$。

### 2.2 优化 & 过程

直接最朴素的计算前缀函数时间复杂度为 $O(n^3)$，故我们可以加入优化。

优化一：每次新加入一个数时，贡献最多加 $1$，即 $\pi[i + 1] \le \pi[i] + 1$ ，取等当且仅当 $s[\pi[i] + 1] == s[i + 1]$。

优化二：其实优化一的情况优化了新加入的数依然匹配成功的情况，那么优化二可以优化新加入的数失配的情况。我们假设记录一个数组 $k$，$k[i]$ 表示第 $i + 1$ 位失配之后应该跳到第 $k[i]$ 位上。那么我们每次可以不断向前跳，如果匹配成功就是优化一的情况，匹配不成功就继续回跳。

我们假设向前回跳一次到达的位置为 $j$。仔细观察，我们发现 $s[0\dots j] = s[i - j \dots i] = s[\pi[i] - j \dots \pi[i]](j < \pi[i])$，那么则有 $j = \pi[\pi[i]]$，故每次向前跳只需让 $j = k[j]$，等找到适配时就按优化一更新，一直适配不成功就按 $0$ 来更新 $k[i]$。这样的话相当于让该串自己匹配自己来求 $k[i]$，然后求该串在其他串中出现的位置就让该串与其他串匹配，等到 $j$ 变为该串的长度时，说明整个串出现了，可以记录下出现的位置了。

### 2.3 实现

```c++
void kmp() {
  int len_a = strlen(a + 1), len_b = strlen(b + 1);
  int j = 0;
  for(int i = 2; i <= len_b; i++) { // i 要从 2 开始，不然的话计算前缀函数会把自身也算上，变为 k[i] = i
    while(j && b[j + 1] != b[i]) j = k[j];
    if(b[j + 1] == b[i]) j++;
    k[i] = j;
  }
  j = 0;
  for(int i = 1; i <= len_a; i++) {
    while(j && b[j + 1] != a[i]) j = k[j];
    if(b[j + 1] == a[i]) j++;
    if(j == len_b) cout << i - j + 1 << endl;
  }
  for(int i = 1; i <= len_b; i++) cout << k[i] << ' ';
  cout << endl;
}
```

