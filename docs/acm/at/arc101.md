# ARC101 ~ 110

## [AtCoder Regular Contest 104](https://atcoder.jp/contests/arc104)

### [C. Fair Elevator](https://atcoder.jp/contests/arc104/tasks/arc104_c)

**Solution**

有必要事先说明一下题意。

> $2n$ 个位子，被划分为 $n$ 个区间，这 $n$ 个区间允许重叠，但是重叠的区间长度都是相等的。且每个位子都只能是一个区间的起点或终点，给定其中一部分起点和终点，问是否存在满足条件的情况。

然后我们发现一个区间如果满足条件，要么这个区间可以划分为更小的符合条件的区间，要么这个区间一定是形如 `(1, 2, 3, ..., k, 1, 2, 3, ..., k)` 这样一一对应的情况。

且 $n$ 的范围很小，可以直接 $O(n^3)$ 暴力 dp 即可。


### [D. Multiset Mean](https://atcoder.jp/contests/arc104/tasks/arc104_d)

**Solution**

本题学到了前缀和优化多重背包。

一个很巧妙的转化，因为 $\sum p_i \times i \equiv 0 (\mod x)$，其中 $p_i \le k$。

我们不知道和是 x 的多少倍，所以我们可以把每个数均减去 x，平均数就是 0。那么 `1, 2, ..., n` 就变成了 `1 - x, 2 - x, ...,  n - x`。

整个数列分为负数部分，0，正数部分，0 可以随便取，有 k + 1 种取法。负数和正数部分和相等。

令 $f_{i, j}$ 表示用 $1 ~ i$ 且每个数不超过限制情况下凑成 $j$ 的方案数。可以用多重背包解决。

最终对于答案计算，$ans_x = (\sum_{j = 1}^{kn(n + 1) / 2}(k + 1)f_{x - 1, j}f_{n - x, j}) - 1$，减 1 是减去空集对答案的贡献。

直接 dp 复杂度是 $O(n^3k^2)$，我们采用前缀和优化，思路就是先把当作完全背包算，然后减去选了 $k + 1$ 及以上的方案数（减的时候要从大到小）。时间复杂度是 $O(n^2k^2)$。

## [AtCoder Regular Contest 105](https://atcoder.jp/contests/arc105)

### [C. Fair Elevator](https://atcoder.jp/contests/arc104/tasks/arc105_c)

**Solution**

由于 n 很小，直接 n! 枚举全排列。对于一种固定的排列，本题实际上是加上了 $\dfrac{n(n + 1)}{2}$ 个限制条件，即对于每对 (i, j)，至少满足 i ~ j 的长度大于等于 **承受质量小于这段和的段落的最长长度**。所以我们每次从前往后加入一个牛 `p[i]` 后，我们要满足所有关于 `p[i]` 的条件。设 `f[i]` 表示前 i 头牛的最小长度，那么则有 `f[i] = max{f[i], f[j] + len[i, j]}`。因为要所有的限制条件均满足所以要取 max。

最后对所有的排列取 `min{f[n]}` 即可。

### [D. Multiset Mean](https://atcoder.jp/contests/arc104/tasks/arc105_d)

**Solution**

博弈论，但不能用 SG 函数解答。

思考发现把袋子里的硬币全倒出来之后，先后手的情况是固定的。而且此时是一个典型 Nim 游戏。

然后一般思考这类问题还是考虑一些极端取法（往往是正解）。

如果有奇数个，那么最后是第二个人先取盘子的硬币，他希望异或和不为 0，那么是否存在操作使得**某个盘子上的硬币数严格大于总硬币数的一半呢**，是可以做到的。他只要每次轮到他操作时取最多的袋子，放到第一个人第一次放的盘子上。这样其他盘子的 $\sum_{i = 2}^k \oplus a_i \le \sum_{i = 2}^k a_i < a_1$，故后手必胜。

如果有偶数个，那么最后是第二个人先取盘子的硬币，他希望异或和不为 0。他也可以每次倒出硬币数最多的放到一个盘子里，第二个人的策略其实也相同，那么第二个人放在盘子里的硬币数一定小于或等于第一个人的。判断一下是否可能相等，不相等就第一个，否则第二个。




