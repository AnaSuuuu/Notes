# 常规 DP

## 习题

[**CF1216F Wi-Fi**](https://codeforces.com/contest/1216/problem/F)

**Solution**

设 `f[i]` 表示连通 $1 \sim i$ 的最小代价。因为操作的时候可能前面不连，然后通过 router 从后面把前面一起连上。所以这里转移的时候，找 $[i - k, i + k]$ 范围内最靠前的 router 位置，若存在，则可以通过那个 router 转移，否则就只能直连。

[**CF2025D Attribute Checks**](https://codeforces.com/contest/2025/problem/D)

**Solution**

其实是个稍微有点转化的 dp，但是没想起来TAT。。

不难想到设 `f[i][j]` 表示 $i$ 个加到 $|S|$ 上，$j$ 个加到 $|I|$ 上。

直接这样转移的话时间复杂度是 $O(nm)$ 的，无法接受。

稍作转化，我们设 `f[i]` 表示到当前位置为止给 $|S|$ 用了 $i$ 个的最大收益。

我们设走到当前位置一共可以改变 $cnt$ 次。那么如果出现一个正数 $x$，对 `f` 数组贡献的区间是 $f_x \sim f_{cnt}$，如果出现一个负数 $x$，对 `f` 数组贡献的区间是 $f_0 \sim f_{x + cnt + 1}$。

区间修改可以用线段树，但是没必要。这里用差分数组即可。

对于出现一个 $0$ 时，转移方程为 $f_i = \max\{f_i, f_{i - 1}\}$。所以我们先恢复成原数组，再转移，再变成差分数组。操作一次时间复杂度为 $O(m)$，一共 $m$ 个 $0$，最终时间复杂度为 $O(n + m^2)$。

[**Leetcode 3389**](https://leetcode.cn/contest/weekly-contest-428/problems/minimum-operations-to-make-character-frequencies-equal/description/)

> 给你一个字符串 $s$。如果字符串 $t$ 中的字符出现次数相等，那么我们称 $t$ 为 好的。
> 
> 你可以对 $s$ 进行增添，删减任意个字符或让字母变成字母表下一个字母，但是不能将 'z' 变为 'a'。
> 
> 请你返回将 $s$ 变 好的 最少操作次数。

**Solution**

分情况讨论的 DP。

我们首先枚举最终字符出现次数，那么每种字符要么出现 $num$ 次，要么 $0$ 次。

我们分别令 `f[i][0]` 和 `f[i][1]` 为这两种情况下的最佳答案。

分情况讨论，其实只有前一个字符次数多于 $num$ 且当前字符少于 $num$ 且最终要变为 $num$

或 前一个字符次数最终要变为 $0$ 且当前字符少于 $num$ 且最终要变为 $num$ 时才会出现向后移。

其他都是正常增删即可。即讨论相邻 `00`，`01`，`11`，`10` 的情况即可。


