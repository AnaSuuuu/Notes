# 常规 DP

## 习题

[**CF1216F Wi-Fi**](https://codeforces.com/contest/1216/problem/F)

**Solution**

设 `f[i]` 表示连通 $1 \sim i$ 的最小代价。因为操作的时候可能前面不连，然后通过 router 从后面把前面一起连上。所以这里转移的时候，找 $[i - k, i + k]$ 范围内最靠前的 router 位置，若存在，则可以通过那个 router 转移，否则就只能直连。

[**CF2025D Attribute Checks**](https://codeforces.com/contest/2025/problem/D)

**Solution**

其实是个稍微有点转化的 dp，但是没想起来TAT。。

不难想到设 `f[i][j]` 表示 $i$ 个加到 $|S|$ 上，$j$ 个加到 $|I|$ 上。

直接这样转移的话时间复杂度是 $O(nm)$ 的，无法接受。

稍作转化，我们设 `f[i]` 表示到当前位置为止给 $|S|$ 用了 $i$ 个的最大收益。

我们设走到当前位置一共可以改变 $cnt$ 次。那么如果出现一个正数 $x$，对 `f` 数组贡献的区间是 $f_x \sim f_{cnt}$，如果出现一个负数 $x$，对 `f` 数组贡献的区间是 $f_0 \sim f_{x + cnt + 1}$。

区间修改可以用线段树，但是没必要。这里用差分数组即可。

对于出现一个 $0$ 时，转移方程为 $f_i = \max\{f_i, f_{i - 1}\}$。所以我们先恢复成原数组，再转移，再变成差分数组。操作一次时间复杂度为 $O(m)$，一共 $m$ 个 $0$，最终时间复杂度为 $O(n + m^2)$。



