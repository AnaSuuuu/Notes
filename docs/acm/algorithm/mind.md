# 小清新思维 && 构造



## 习题

[**CF802H Fake News (medium)**](https://codeforces.com/contest/802/problem/H)

> 给定 $n$，构造出子串 $p$ 和 $s$，使得 $p$ 恰在 $s$ 中出现 $n$ 次。其中 $p$ 和 $s$ 的长度均不超过 $200$。

**Solution**

巧妙构造题。



方法一：

由于这个长度有限制，最后多半按照形如进制拆分的形式去构造。

且最后是选择子串，我们想到和组合数相关。一开始想选择的 $p$ 是 `ab`，但是这样很难能达到 $n$ 个数。

故选择 $p$ 可以是连续若干 $a$ 加上一个 $b$。假定 $p$ 是 `aaaaab`，那么最后的答案就是形如 

$$
\sum_{i = 1} a_i \times \binom{n}{5}。
$$

这个式子就和进制拆分有点类似了，并且我们发现这个 $a_i$ 和 $n$ 都不可能太大，所以按这种方法构造即可。

```cpp
void solve() {
	int n;
	std::cin >> n;
	std::string s = "", p = "";	
	auto calc = [](i64 x) -> i64 {
		if (x <= 4) return 0;
		return x * (x - 1) * (x - 2) * (x - 3) * (x - 4) / (1 * 2 * 3 * 4 * 5);
	};
	std::vector<int> cnt(105, 0);
	for (int i = 100; i >= 1; ) {
		while (calc(i) > n) {
			i--;
		}
		n -= calc(i);
		cnt[i]++;
		if (n == 0) break;
	}
	for (int i = 1; i <= 100; i++) {
		std::cout << "a";
		while (cnt[i]--) std::cout << "b";
	}	
	std::cout << " aaaaab\n";
}
```

方法二：（官方做法）

我们假设现在已经构造出 $p$ 恰好在 $s$ 中出现了 $k$ 次。

那么由于我们要在长度不太长的情况下能够造出 **任意且足够大** 的数。

我们不难想到要可以从 $k \to k + 1$ 以及 $k \to 2k$。

- 对于 $k \to 2k$ 比较简单，设现在是 $p$ 和 $s$，那么 $p' = px$，$s' = sxx$（$x$ 是之前没出现的字母）。
- 对于 $k \to k + 1$ 比较复杂，但是我们可以构造出 $k \to 2k + 1$。设现在是 $p$ 和 $s = pu$，那么 $p' = px$，$s' = pxuxx$（$x$ 是之前没出现的字母）。注意这里 $s$ 并不用严格等于 $pu$，这里前面的 $p$ 即表示 $s$ 中 $p$ 首次出现的位置。

这里第二个构造很巧妙。可以这样想，第一个 $x$ 只能和前面的 $p$ 配对，贡献为 $1$，后面的两个 $x$ 均和 $pxu$ 配对，贡献都是 $k$，故 $k \to 2k + 1$。

有这样的操作之后就可以把 $n$ 按二进制划分，然后逐位构造。


